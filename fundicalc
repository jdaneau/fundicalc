#!/usr/bin/env Rscript
library(phangorn)
library(ape)
iqtree <- "iqtree2203"
source("convert_tree.R")
source("root_tree.R")
##------------------------------------------------------------------------------

# FunDi Calc attempts to optimize the parameters (rho,t) for the FunDi model
# Requires a functional divergence point as input as well as an IQTREE model string
# Current method : Optimize rho for a grid of equally-spaced t values. Find the best t

##------------------------------------------------------------------------------

# get a vector of site likelihoods from the .sitelh file generated by IQTREE
site_likelihood <- function(sitelhfile) {
  tab <- read.table(sitelhfile,header=TRUE,fill=TRUE)
  return(tab[,2])
}

# prune the sequence file to only have the taxa that appear in a given tree
tree_seq <- function(seqfile,names,pref) {
  seq <- read.aa(seqfile)

  rows.to.keep <- which(row.names(seq) %in% names)
  seq <- seq[rows.to.keep,]
  
  write.data <- phyDat(seq, type = "AA")
  write.phyDat(write.data, paste0(pref,".",seqfile),format = "sequential")
}

# flush out all iqtree output that was generated
rem_iqtree <- function() {
  did.remove <- file.remove(list.files(path=getwd(), pattern=paste0("^.*tmp\\.(log|ckp\\.gz|iqtree|sitelh|siteprob)$")))
}

# optim_rho is the subroutine that optimizes rho given a fixed t value
optim_rho <- function(lAB,lA,lB) {
  # Initialize values
  n <- length(lAB)
  p <- 0.5
  pn <- 0
  thresh <- 1.0e-6
  prev.sum <- -Inf
  sums <- vector()
  lmax <- vector(length=n)
  lf <- vector(length=n)
  
  update_lf <- function(){
    for(i in 1:n) {
      lmax[i] <<- max(lA[i]+lB[i], lAB[i])
      lf[i] <<- lmax[i] + log(p*exp(lA[i]+lB[i]-lmax[i]) + (1-p)*exp(lAB[i]-lmax[i]) )
    }
    s <- sum(lf)
    if(s < prev.sum) stop(paste("lf sum did not increase. something bad happened:",prev.sum,">",s))
    prev.sum <<- s
    sums <<- append(sums, s)
  }
  update_lf()
  
  mean_i <- function() {
    sum <- 0
    for(i in 1:n) {
      sum <- sum + 
        ( p*exp(lA[i]+lB[i] - lmax[i]) / exp(lf[i] - lmax[i]) )
    }
    return(sum/n)
  }
  
  # Main loop
  while(abs(pn-p) > thresh) {
    pn <- mean_i()
    p <- pn
    update_lf()
    p <- mean_i()
  }
  
  return(c(p,prev.sum)) # returns [rho,lf]
}

##----------------------------

## Process Command Line
args <- commandArgs()
iarg <- length(args)

FnameE <- function(fname){
  if(!file.exists(fname)) stop(paste(fname,"does not exist"))
  return(fname)
}

seqfile <- treefile <- taxafile <- rootfile <- splitfile <- model <- NULL
grid.size <- 4
while(iarg>=6){
  if(substring(args[iarg],1,1)=='-'){
    opt <- args[iarg]
    is.opt <- TRUE
  }else{
    val <- args[iarg];
    is.opt <- FALSE
  }
  if(is.opt){
    not.an.option <- TRUE
    if(opt=="-s"){
      seqfile <- FnameE(val); not.an.option <- FALSE
    }
    if(opt=="-t"){
      treefile <- FnameE(val); not.an.option <- FALSE
    }
    if(opt=="-r"){
      rootfile <- FnameE(val); not.an.option <- FALSE
    }
    if(opt=="-l"){
      splitfile <- FnameE(val); not.an.option <- FALSE
    }
    if(opt=="-m"){
      model <- val; not.an.option <- FALSE
    }
    if(opt=="-g"){
      grid.size <- as.numeric(val); not.an.option <- FALSE
    }
    if(not.an.option) stop(paste(opt,"is not an option\n"))
  }
  iarg <- iarg-1
}
if(is.null(seqfile)) stop("Need sequence file: -s seqfile")
if(is.null(treefile)) stop("Need tree file: -t treefile")
if(is.null(model)) stop("Need model: -m model")
if(is.null(splitfile)) stop("Need file with integer labels of taxa on one side of split: -l splitfile")
if(is.null(rootfile)) stop("Need file with integer labels of taxa on one side of root: -r rootfile")

##--------------------------------

lAB <- lA <- lB <- -1
run_iqtree <- function(fix=TRUE,tree=treefile) {
  # run system call to iqtree
  if(fix)
    system(paste(iqtree,"-s",seqfile,"-me 1 -m",model,"-nt 10 -pre tmp -te",tree,"-redo -mwopt -wspm -wslmr -quiet -blfix"))
  else
    system(paste(iqtree,"-s",seqfile,"-me 1 -m",model,"-nt 10 -pre tmp -te",tree,"-redo -mwopt -wspm -wslmr -quiet"))
  
  # get site likelihood vector from iqtree output file
  lAB <<- site_likelihood("tmp.sitelh")
}
# do initial IQTREE run (don't fix edge lengths)
run_iqtree(fix=FALSE) 

# run rtsplit
cmd <- paste("rtsplit -s",seqfile,"-t tmp.treefile -r",rootfile,"-l",splitfile)
system(cmd)

A <- "A.tmp.treefile"; B <- "B.tmp.treefile"
Anames <- "A.tmp.treefile.names"; Bnames <- "B.tmp.treefile.names"

# convert rtsplit output to newick
nA <- read.tree(text=ut2nrt(utree(A),unames(Anames))); write.tree(nA,file=A)
nB <- read.tree(text=ut2nrt(utree(B),unames(Bnames))); write.tree(nB,file=B)

# generate sequence files for tree A and B
tree_seq(seqfile, unames(Anames), "A"); A.seqfile <- paste0("A.",seqfile)
tree_seq(seqfile, unames(Bnames), "B"); B.seqfile <- paste0("B.",seqfile)

system(paste(iqtree,"-s",A.seqfile,"-me 1 -m",model,"-nt 10 -pre A.tmp -te A.tmp.treefile -redo -mwopt -wspm -wslmr -quiet"))
system(paste(iqtree,"-s",B.seqfile,"-me 1 -m",model,"-nt 10 -pre B.tmp -te B.tmp.treefile -redo -mwopt -wspm -wslmr -quiet"))
lA <- site_likelihood("A.tmp.sitelh")
lB <- site_likelihood("B.tmp.sitelh")  
rem_iqtree()

# do the first round of optimization
rho <- optim_rho(lAB,lA,lB)
cat(paste("Initial rho =",rho[1],", lf =",rho[2],"\n"))

taxa <- scan(splitfile,what=integer(),quiet=TRUE)

# get the initial optimization for t from IQTREE output
make.utree("tmp.treefile",seqfile,"tmp.AB.utreec","tmp.AB.utreec.names")
uAB <- root_tree("tmp.AB.utreec",taxa); write.table(uAB, file="tmp.AB.utreec", row.names=FALSE, col.names=FALSE)
ABnames <- "tmp.AB.utreec.names"
tmax <- best.t <- sum(uAB[nrow(uAB),3:4]) # take the last row from the utreec matrix (split root)
cat(paste("IQ-TREE optimized edge length t:",tmax,"\n"))

# form grid
tmp.grid <- seq(0,tmax,tmax/grid.size)
grid <- vector(length=grid.size)
for(i in 1:grid.size){
  grid[i] = (tmp.grid[i] + tmp.grid[i+1]) / 2
}
cat(paste0("Grid to use: [",paste(grid,collapse=" "),"]\n"))

i <- 1

# MAIN LOOP: go through grid and find the best value of rho
for(t in grid){
  # update the split edge of AB to new t value, convert to newick and overwrite the temp treefile
  uAB[nrow(uAB),3:4] <- c(t,0); #write.table(uAB, file=paste0("tmp.",i,".ut.debug"), row.names=FALSE, col.names=FALSE)
  nAB <- read.tree(text=ut2nrt(uAB,unames(ABnames)))
  write.tree(nAB,"tmp.AB.treefile"); 
  
  # get the iqtree output for the updated edge length
  run_iqtree(tree="tmp.AB.treefile")
  
  # optimize rho and set it as the new best choice if the LF value is greater than previous rho
  new.rho <- optim_rho(lAB,lA,lB)
  cat(paste("t =",t,paste0("(",i,"/",grid.size,")"),": rho =",new.rho[1],", lf =",new.rho[2],"\n"))
  if(new.rho[2] > rho[2]) {
    best.t <- t
    rho[1] <- new.rho[1]; rho[2] <- new.rho[2]
    cat(paste("New best found; rho updated to",rho[1],"\n"))
  }
  
  rem_iqtree()
  i <- i+1
}

cat(paste("FINISHED: best rho =",rho[1],", lf =",rho[2],", t =",best.t,"\n"))

# remove the rest of the generated files
to.remove <- c("tmp.AB.utreec","tmp.AB.utreec.names","tmp.AB.treefile",
               uAB, ABnames, A, B, Anames, Bnames, 
               paste0("A.",seqfile),paste0("B.",seqfile))
did.remove <- file.remove(to.remove)
